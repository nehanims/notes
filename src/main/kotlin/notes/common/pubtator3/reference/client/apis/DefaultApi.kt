/**
 * PubTator3 API
 * This API provides functionality to retrieve biomedical text annotations and related entities. 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package notes.common.pubtator3.reference.client.apis

import notes.common.pubtator3.reference.client.models.InlineResponse200
import notes.common.pubtator3.reference.client.models.InlineResponse2001
import notes.common.pubtator3.reference.client.models.InlineResponse2002

import notes.common.pubtator3.reference.client.infrastructure.*

class DefaultApi(basePath: kotlin.String = "https://www.ncbi.nlm.nih.gov/research/pubtator3-api/") : ApiClient(basePath) {

    /**
     * Find Entity ID by Query and Concept
     * This endpoint allows users to search for entity identifiers based on a free text query. Optionally, users can specify a bioconcept type and limit the number of returned identifiers. 
     * @param query Free text query to search for bioconcept identifiers. 
     * @param concept Optional bioconcept type to filter results. Can be one of the following: &#x60;gene&#x60;, &#x60;disease&#x60;, &#x60;chemical&#x60;, &#x60;species&#x60;.  (optional)
     * @param limit Optional parameter to limit the number of results returned. If not specified, the default limit is applied.  (optional)
     * @return kotlin.Array<InlineResponse200>
     */
    @Suppress("UNCHECKED_CAST")
    fun entityAutocompleteGet(query: kotlin.String, concept: kotlin.String? = null, limit: kotlin.Int? = null): kotlin.Array<InlineResponse200> {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            put("query", listOf(query.toString()))
            if (concept != null) {
                put("concept", listOf(concept.toString()))
            }
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
        }
        val localVariableConfig = notes.common.pubtator3.reference.client.infrastructure.RequestConfig(
            RequestMethod.GET,
            "/entity/autocomplete/", query = localVariableQuery
        )
        val response = request<kotlin.Array<InlineResponse200>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<InlineResponse200>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Find Related Entities
     * This API allows users to find related entities by providing an &#x60;entityId&#x60; (found through \&quot;Find Entity ID\&quot;). Optionally, users can filter results by &#x60;relation_type&#x60; and &#x60;entity_type&#x60;. 
     * @param e1 The entity ID to query related entities for. 
     * @param type The relation type to filter by (optional). (optional)
     * @param e2 The entity type to filter related entities by (optional). (optional)
     * @return kotlin.Array<InlineResponse2002>
     */
    @Suppress("UNCHECKED_CAST")
    fun relationsGet(e1: kotlin.String, type: kotlin.String? = null, e2: kotlin.String? = null): kotlin.Array<InlineResponse2002> {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            put("e1", listOf(e1.toString()))
            if (type != null) {
                put("type", listOf(type.toString()))
            }
            if (e2 != null) {
                put("e2", listOf(e2.toString()))
            }
        }
        val localVariableConfig = notes.common.pubtator3.reference.client.infrastructure.RequestConfig(
            RequestMethod.GET,
            "/relations", query = localVariableQuery
        )
        val response = request<kotlin.Array<InlineResponse2002>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<InlineResponse2002>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Search Publications by Text, Entity ID, or Relations
     * Query through this API to retrieve relevant publications returned by PubTator3. The query can be in the form of free text, entity ID (e.g., @CHEMICAL_remdesivir), or relations between entities. Query relations can be specified as relations between two entities (e.g., relations:ANY|@CHEMICAL_Doxorubicin|@DISEASE_Neoplasms) or relations between one entity and entities of a specific type (e.g., relations:ANY|@CHEMICAL_Doxorubicin|DISEASE). 
     * @param text The free-text query or entity ID to search for. 
     * @param page The page number for paginated results (default is 1). (optional, default to 1)
     * @return InlineResponse2001
     */
    @Suppress("UNCHECKED_CAST")
    fun searchGet(text: kotlin.String, page: kotlin.Int? = null): InlineResponse2001 {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            put("text", listOf(text.toString()))
            if (page != null) {
                put("page", listOf(page.toString()))
            }
        }
        val localVariableConfig = notes.common.pubtator3.reference.client.infrastructure.RequestConfig(
            RequestMethod.GET,
            "/search/", query = localVariableQuery
        )
        val response = request<InlineResponse2001>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as InlineResponse2001
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
